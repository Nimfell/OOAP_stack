
// ======================================================== 
// 2.1 Опишите АТД LinkedList с предложенным набором операций.
// ======================================================== 
  
abstract class LinkedList<T>
{
    // ================================================ 
    // статусы:

    public enum status_cmd
    {
        HEAD,
        TAIL,
        RIGHT,
        PUT_RIGHT,
        PUT_LEFT,
        REMOVE,
        ADD_TAIL,
        REPLACE,
        FIND,
        REMOVE_ALL,
        GET_COMMAND
    }

    public const int NIL = 0; // команда не вызывалась
    public const int OK = 1;  // команда отработала нормально
    public const int ERR = 2; // ошибка при выполнении команды  

    // ================================================ 
    // конструктор:
    public LinkedList<T> BoundedStack(); // постусловие: создан новый пустой лист

    // ================================================ 
    // команды:

    // предусловие: лист не пустой
    // постусловие: курсор установлен на первый узел
    public void head();

    // предусловие: лист не пустой
    // постусловие: курсор установлен на последний узел
    public void tail();

    // предусловие: справа есть узел
    // постусловие: курсор установлен на один узел вправо 
    public void right();

    // предусловие: курсор установлен
    // постусловие: вставлен новый узел следом за текущим узлом с заданным значением;
    public void put_right(T val);

    // предусловие: курсор установлен
    // постусловие: вставлен новый узел перед за текущим узлом с заданным значением;
    public void put_left(T val);

    // предусловие: курсор установлен
    // постусловие: удален текущий элемент, 
    //              курсов переставлен на левый или правый узел или убран, если лист пуст.
    public void remove();

    // постусловие: лист пуст, все значения выставлены в первоначальные
    public void clear(); 
    
    //--------------------
    // постусловие: в хвост добавлен новый узел с заданным значением
    public void add_tail(T val);

    // предусловие: курсор установлен
    // постусловие: значение текущего узла заменено на заданное;   
    public void replace(T val);

    // предусловие: курсор установлен
    // постусловие: курсор установлен на следующий узел  с искомым значением (по отношению к текущему узлу)
    public void find(T val);

    // предусловие: в листе есть хотя бы один узел с заданным значением
    // постусловия: удалены все узлы с заданным значением, 
    //              если на удаленном узле стоял курсор, то он смещается по правилу remove()
    public void remove_all(T val); 

    // ================================================ 
    // запросы: 
  
    // предусловие: курсор установлен
    public T get(); //-- получить значение текущего узла;

    public int size(); //-- посчитать количество узлов в списке.
    //--------------------
    public bool is_head;  //-- находится ли курсор в начале списка?
    public bool is_tail;  //-- находится ли курсор в конце списка?
    public bool is_value; //-- установлен ли курсор на какой-либо узел в списке (по сути, непустой ли список).

    // предусловие: запрашиваемый статус команды есть в перечислении
    public int get_command_status(int command); // возвращает статус выполнения запрашиваемой команды.
}
 

/*
 // ======================================================== 
 2.2 Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?
 * Потому что она очень проста и tail должен быть в шаговой доступности (не требуется других операций для поиска и т.д.).
 * Потому что есть команда add_tail(), где другими операциями её не заменить
 * 
 // ========================================================
 2.3 Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?
 * Потому что можно вне класса создать лист со значениями и заполнять его по циклу, используя имеющийся интерфейс данной реализации 
 */


